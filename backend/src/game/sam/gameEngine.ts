import { CurrentGameState } from "../../types/game";import { Card } from "../shared/cards";import { log } from "../../lib/utils";import { MoveStatus, validateMove } from "./rules/validateMove";import { getNextPlayer, getPreviousPlayer } from "./helpers/getPlayer";import { calculateTransaction } from "./helpers/transaction";/** * Plays a card in the game. * * What this method does is basically taking in the current game state, update it then return it back to be updated on Redis database: * 1. Validate the move. * 2. Apply the move. * 3. Check if the player has won. * 4. Update the game state. * * @param gameState Current game state. * @param socketId Socket ID of the player making the move. * @param move Cards being played. * @param pass Boolean indicating if the player is passing (not playing). * @returns Description of the return value. */export const playCard = (  gameState: CurrentGameState,  socketId: string,  move: Card[],  pass: boolean,): CurrentGameState | null => {  // If the last move is also made by the current player, then refresh the lastPlayed cards, and the current player starts a new round  if (!pass && gameState.lastPlayed?.socketId === socketId) {    gameState.lastPlayed = {socketId: "", cards: []};  }  // If the player passes, change nothing to the game state and continue with the next player  if (pass) {    gameState.currentTurn = getNextPlayer(gameState, socketId).socketId;    return gameState;  }  // Find the player currently playing  const player = gameState.players.find((p) => p.socketId === socketId);  // If the player is not found, log an error and throw an exception  if (!player) {    log("Invalid player", "error");    throw new Error("Invalid player");  }  const currentHand = player.hand;  // 1. Validate move  const lastPlayed = gameState.lastPlayed || null;  if (validateMove(lastPlayed?.cards, move, currentHand, player.mustBeat) === MoveStatus.INVALID)    throw new Error("Invalid move");  // 2. Apply move  // Remove played cards from player's hand  for (const card of move) {    player.hand = player.hand.filter((c) => !c.equals(card));  }  // Update currentTurn to the next player -> if there is no player that can defend, the currentTurn will go around and go back to current player  gameState.currentTurn = getNextPlayer(gameState, socketId).socketId;  // Update last played cards  gameState.lastPlayed = {socketId: socketId, cards: move};  // If the current hand has only one card left, set mustBeat to true for the previous player  if (player.hand.length === 1) {    const previousPlayer = getPreviousPlayer(gameState, socketId);    previousPlayer!.mustBeat = true;  }  // 3. Check win  if (player.hand.length === 0) {    gameState.phase = "finish";    const otherPlayers = gameState.players.filter((p) => p.socketId !== socketId);    calculateTransaction(gameState, otherPlayers, player, gameState.betUnit);    log(`Player ${socketId} wins!`, "info");  }  return gameState;};